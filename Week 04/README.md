# Функции

### Какво е функция?

**Функция** е самостоятелен блок код, който изпълнява определена задача. Всяка функция може да приема входни данни (параметри) и да връща резултат (връщана стойност). Основната цел на функциите е да улеснят организирането на кода, като разделят сложните програми на по-малки и управляеми части, които могат да се използват многократно.

### Структура на функция

Функциите в C++ се състоят от няколко основни компоненти:

1. **Тип на връщане** (сигнатура) – указва какъв тип данни ще върне функцията (например int, double, void, и т.н.)
2. **Име** (идентификатор) на функцията – как се нарича функцията. Това е начинът, по който ще я извикваме
3. **Параметри** – променливите, които функцията приема като входни данни. Те могат да бъдат нула или повече
4. **Тяло** на функцията – кода, който се изпълнява, когато функцията бъде извикана

```cpp
<сигнатура> <идентификатор> (<параметър1>, <параметър2> ...) {
      <тяло>
}
```

### Операторът `return`

Операторът return се използва във функциите, за да върне резултат. Той спира изпълнението на функцията и предава стойността (ако има такава) обратно към извикващия код.

Нека да разгледаме пример за функция, която събира две числа и връща резултата:

```cpp
#include <iostream>
using namespace std;

int sum(int a, int b) {
    return a + b;
}

int main() {
    int num1 = 5;
    int num2 = 7;

    int result = sum(num1, num2);

    cout << "Резултатът е: " << result << endl;

    return 0;
}
```

Когато операторът `return` се изпълни, останалата част от функцията се пропуска. Това е полезно, ако искаме да прекратим изпълнението на функцията при определено условие.

```cpp
double divide(double a, double b) {
    if (b == 0) {
        std::cout << "Error! Cannot divide by 0!" << std::endl;
        return -std::numeric_limits<double>::max(); // някаква специална стойност за грешка
    }

    return a / b;
}
```

### Функции без връщана стойност (`void`)

Ако функцията няма да връща никаква стойност, нейният тип на връщане е `void`, а операторът `return` може да се използва само за прекъсване на изпълнението на функцията без връщане на стойност.

```cpp
void printEvenOrOdd(int num) {
    if (num % 2 == 0) {
        cout << "Even" << endl;
        return;
    }

    cout << "Odd" << endl;
}
```

### Предимства на функциите

1. **Разделяне на логиката**: Програмите стават по-структурирани и лесни за разбиране

2. **Повторна употреба**: След като функцията е създадена, можем да я използваме многократно без да пишем същия код отново

3. **Модулиране на програмата**: По-малките, самостоятелни парчета код улесняват откриването на грешки и добавянето на нова функционалност

### Още важни неща за функциите!

- **Декларация и дефиниция**: Функцията може да бъде декларирана преди main, а самата ѝ дефиниция да е след main. Това става чрез прототипи на функции, които казват на компилатора какви типове параметри и връщане да очаква, без да съдържат самото тяло.

  ```cpp
  int multiply(int, int); // Декларация на функцията

  int main() {
      cout << multiply(3, 4) << endl;
      return 0;
  }

  int multiply(int a, int b) { // Дефиниция на функцията
      return a * b;
  }
  ```

- **Параметри**: В параметрите на функцията може да се предават стойности. Когато ги подаваме като копие, те се копират и използват вътре в тялото на функцията.

  ```cpp
  void f(int n) {
      n += 2;
  }

  int main() {
      int n = 5;
      f(n);
      cout << n; // 5
  }
  ```

  Бихте си помислили, че след изпълнение на функцията, n ще се увеличи с 2, но това няма да се случи. Понеже подаваме променливата n като копие, тя ще се копира вътре в тялото на функцията и промените ще се изпълнят само върху копието, което ще се изтрие след приключване на функцията. Самата променлива n няма да бъде променена! Как можем да променяме променливите след изпълнение на функциите, ще разберете по - напред в курса...

### Function overloading

**Function overloading** е техника, при която се дефинират множество функции с едно и също име, но с различен брой и/или тип параметри. Компилаторът избира коя функция да извика, базирано на типовете и броя на аргументите, които се подават при извикването на функцията. Това прави кода по-четим и лесен за използване, особено когато искаме да приложим същата логика върху различни типове данни или различни комбинации от аргументи.

Примери:

```cpp
int add(int a, int b) {
    return a + b;
}

double add(double a, double b) {
    return a + b;
}

int main() {
    cout << "Sum of integers: " << add(5, 10) << endl; // 15
    cout << "Sum of floating point numbers: " << add(5.5, 10.2) << endl; // 15.7
}
```

В този пример имаме две функции `add`, едната приема `int` аргументи, а другата – `double`. Когато извикаме `add` с цели числа, се използва първата версия, а когато извикаме с дробни – втората.

```cpp
int multiply(int a, int b) {
    return a * b;
}

int multiply(int a, int b, int c) {
    return a * b * c;
}

int main() {
    cout << "Multiplication of two numbers: " << multiply(5, 10) << endl; // 50
    cout << "Multiplication of three numbers: " << multiply(5, 10, 2) << endl; // 100
}
```

Тук имаме две версии на функцията `multiply`. Първата приема два аргумента, а втората – три. Компилаторът автоматично избира правилната версия, базирано на броя на подадените аргументи.

**Забележка:**
Function overloading не е позволен само чрез връщащия тип на функцията. Тоест, няма как да имаме две функции с едно и също име и параметри, които се различават само по типа на връщания резултат.

```cpp
int getValue() {
    return 10;
}

double getValue() { // Грешка: функцията вече съществува с параметри, които не се различават
    return 10.5;
}

int main() {
    cout << getValue() << endl;
}
```

В този код опитваме да дефинираме две версии на функцията `getValue` – едната връща `int`, а другата `double`. Въпреки че типовете на връщаните стойности са различни, компилаторът не може да разграничи функциите, защото и двете приемат същия брой параметри (в случая нямат параметри) и имат същото име. Това води до грешка при компилация.

---

### Стек и стекова рамка

В стековата памет извикванията се базират на принципа LIFO (Last In First Out), или на принципа на абстрактната структура от данни стек. Това поражда и еквивалентния термин **_стекова рамка_** за извикванията на функциите. Най-просто, всяко извикване на една функция обособява **_стекова рамка_** за функцията във стека и заделя своята памет в нея в следната последователност - за параметрите си, return address (адресът на мястото, където ще се върне резултатът), за адреса на предишната стекова рамка и за всичките локални променливи, които тя декларира (включително променливата, която се връща).

```c++
void bar() {}

void foo() {
  bar();
}

int main() {
  foo();
}
```

Кои стекови рамки се намират в стека, във всеки един момент на изпълнение на програмата, са показани на долната картинка:
<img src="https://i.imgur.com/IUGxJPF.jpg" width=100% height=100%>

---

### Какво представляват референциите?

**Референцията** е алтернативно име за съществуваща променлива. Тя действа като псевдоним на променливата и винаги сочи към едно и също място в паметта, към което сочи оригиналната променлива.

Ето някои основни характеристики на референциите:

- След като референцията е свързана с определена променлива, тя не може да сочи към друга променлива. Референцията трябва да се инициализира още при дефиницията.
- Типът на референцията и на променливата, към която сочи, трябва да съвпадат.

- Не може да бъде null (тоест, винаги трябва да сочи към валиден обект в паметта).

```cpp
int main() {
    int x = 10;
    int &ref = x; // ref е референция към x

    ref += 5; // Променяме x чрез ref
    cout << "Стойността на x: " << x << endl; // x става 15
    return 0;
}
```

Тук ref е референция към x. Когато променим ref, променяме и x, тъй като те сочат към едно и също място в паметта.

#### Кога да използваме референции?

- **Когато искаме да избегнем копиране на данни:** Особено полезно при предаване на големи структури, като обекти и масиви, защото така се спестява памет и време.
- **При модификация на оригиналната стойност:** Ако искаме функция да променя оригиналната стойност на променливата, можем да използваме референции.

#### Кога да не използваме референции?

- **Когато искаме да сочим към "нищо" (null):** Референциите трябва винаги да сочат към валиден обект, затова не можем да ги използваме, ако трябва да работим с „празни“ стойности.

- **При нужда от по-голяма гъвкавост:** Ако искаме да сменяме към коя променлива сочим, указателите са по-подходящи.

---

### Какво представляват указателите?

**Указателят** е променлива, която съдържа адреса на друга променлива в паметта. С други думи, той "сочи" към определено място в паметта. Указателите могат да се създават и променят динамично, което ги прави много мощен, но и по-сложен за използване инструмент.

Основни характеристики на указателите:

- **Могат да бъдат null:** Указателите могат да сочат към нищо (nullptr), което позволява по-голяма гъвкавост.
- **Могат да сочат към различни обекти:** Можем да променяме адреса, към който сочи указателят.

```cpp
int main() {
    int x = 10;
    int* p = &x; // p е указател, който сочи към x

    int* p2; // за разлика от референциите тук можем да не даваме стойност

    *p += 5; // Променяме x чрез указателя p
    cout << "x: " << x << endl; // x става 15

    cout << p << endl; // ще принтира адреса, към който сочи указателя
    cout << *p << endl; // 15
    return 0;
}

```

#### Кога да използваме указатели?

- **При работа с динамична памет:** Указателите са необходими за динамично заделяне на памет с операторите `new` и `delete`.
- **Когато искаме да сочим към различни обекти:** Ако искаме да променим към коя променлива сочим, указателите са по-подходящи от референциите.
- **При сложни структури и обработка на данни:** Например в структури от данни като динамични масиви, свързани списъци (linked lists), дървета и графи, указателите са основен инструмент.

#### Кога да не използваме указатели?

- **При прости операции и малки данни:** Използването на указатели може да усложни кода, особено ако няма нужда от динамична памет или манипулация на адреси.
- **Когато не е необходима промяна на адреса:** Ако просто искаме пряк достъп до променлива и няма нужда да променяме към какво сочим, референциите са по-подходящи.

_(но повече по тази тема по - нататък...)_

---

### Подаване на аргументи към функции

Когато предаваме аргументи на функция, имаме три основни начина да го направим:

1. **Подаване по стойност (копие)**

   При подаване по стойност, аргументът, който се подава, се копира в параметъра на функцията. Това означава, че вътре във функцията работим с копие на оригиналната стойност. Ако направим промени върху тази стойност вътре във функцията, те няма да засегнат оригиналната променлива.

   ```cpp
   void increment(int num) {
       ++num; // Променяме локалното копие на num
   }

   int main() {
       int x = 5;
       increment(x);
       cout << "Стойността на x: " << x << endl; // x остава 5
   }
   ```

2. **Подаване чрез референция**

   Когато подаваме аргумент като референция (чрез &), функцията получава пряк достъп до оригиналната променлива, вместо да работи с копие. Това означава, че промените вътре във функцията ще засегнат оригиналната променлива.

   ```cpp
    void increment(int& num) {
        num += 1; // Променяме оригиналната стойност на num
    }

    int main() {
        int x = 5;
        increment(x);
        cout << "x: " << x << endl; // x става 6
    }
   ```

3. **Подаване чрез указател**

   При подаване чрез указател (чрез \*), функцията приема адреса на променливата. За да променим стойността на променливата, използваме оператора \* (дерефериране). Това също позволява на функцията да модифицира оригиналната стойност на променливата, както при подаване чрез референция.

   ```cpp
   void increment(int* num) {
       *num += 1; // Променяме стойността на променливата, към която сочи указателя
   }

   int main() {
       int x = 5;
       increment(&x); // Подаваме адреса на x
       cout << "x: " << x << endl; // x става 6
   }
   ```

---

### Връщане на стойности от функции

Функциите могат да връщат стойности, указатели или референции.

1. **Връщане на стойност (копие)**

   При връщане по стойност, функцията връща копие на резултата. Това означава, че промените, направени върху върнатата стойност извън функцията, няма да засегнат оригиналната променлива.

   ```cpp
   int getValue() {
       int a = 5;
       return a; // Връщаме копие на стойността на a
   }

   int main() {
       int result = getValue(); // getValue() връща rvalue
       cout << result; // 5
       getValue() = 10; // грешка!!
   }a
   ```

2. **Връщане на референция**

   При връщане на референция, функцията връща самия обект или променлива, вместо копие. Това е полезно, когато искаме да запазим ефективността (без излишно копиране) и да променяме оригиналната стойност.

   ```cpp
    int& getValue(int& num) {
        return num; // Връщаме референция към num
    }


    int main() {
        int x = 5;
        getValue(x) = 10; // Променяме директно x чрез върнатата референция, понеже референциите са lvalue
        cout << "x: " << x << endl; // x вече е 10
    }
   ```

   **Важно:** трябва да сте сигурни, че променливата, чиято референция връщате, съществува и след приключването на функцията, тоест да не връщате локално създаден обект.

   ```cpp
   int& errorProne() {
       int a = 5;
       return a;
   }
   //Недефинирано поведение, което компилаторът на Visual Studio, любезно заличава, но реално това е проблем и не всички компилатори го позволяват
   ```

3. **Връщане на указател**

   При връщане на указател функцията връща адрес на променлива, вместо самата стойност. Това също позволява промяна на оригиналната стойност, ако работим с адреса.

   ```cpp
   int* getPointer(int &num) {
       return &num; // Връщаме указател към num
   }

   int main() {
       int x = 5;
       *getPointer(x) = 20; // Променяме стойността на x чрез указателя
       cout << "x: " << x << endl; // x става 20
   }
   ```

Припомняме набързо:

- **lvalue** е стойност, която сочи към определено място в паметта (например променлива). Може да бъде модифицирана, ако не е константна.

- **rvalue** е стойност, която не е обвързана с конкретен адрес (например резултат от израз 5 + 3). Тези стойности не могат да се променят директно и обикновено са временни.

---