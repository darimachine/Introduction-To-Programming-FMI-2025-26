**Въпрос 1:** Какво ще се изведе след изпълнение на кода?

```c++
#include <iostream> 

int& tricky(int& a) { 
	a++; 
	return a; 
}

int main() { 
	int x = 10;
	int& y = tricky(x);
	int z = tricky(x); 
	y++; 
	std::cout << x << " " << y << " " << z; 
}
```
<details>
    <summary>Обяснение</summary>
- създаваме int x = 10;<br>
- създаваме референция към int, която кръщаваме 'y', и ѝ присвояваме tricky(x)<br>
- tricky() приема аргумент по референция, увеличава го с едно и връща адреса към този аргумент -> 'y' сочи към мястото в паметта, на което се съхранява нашето 'x', което вече има стойност 11<br>
- разликата при 'z' е, че то запазва в себе си копие на върнатата от tricky(x) стойност, а не адреса ѝ като 'y' -> промени върху оригиналното 'х' ще се отразяват на 'x' и 'y', но НЕ и на 'z'<br>
- 'y++' реално е промяна върху самото 'х', защото, както казахме, 'y' и 'x' се отнасят към едно и също място в паметта(а 'z' - към различно)<br>
- 'x' и 'y' в края са били инкрементирани по 3 пъти и имат стойност 13, а 'z' в момента на създваването си е приело стойност 12, която после не се променя<br>
- изписва се "13 13 12"
</details>
<br>

**Въпрос 2:** Какво ще се изведе след изпълнение на кода?

```c++
#include <iostream>

int global = 1;

int& getRef() {
    return global;
}

int getVal() {
    return global;
}

int main() {
    getRef() = 5;
    std::cout << global << std::endl; // ?
   // getVal() = 10; //will it compile?
}
```
<details>
    <summary>Обяснение</summary>
Валидно, понеже getRef() връща референция към глобалната ни променлива, на която присвояваме 5.<br><br>
Няма да се компилира, ако премахнем коментара, защото опитваме да присвоим стойност на върнатото от getVal() rvalue.
</details>
<br>

**Въпрос 3:** Какво ще се изведе след изпълнение на кода?

```c++
#include <iostream>

void print(int a, int b = 5, char c = 'z') {
    std::cout << a << " " << b << " " << c<<std::endl;
}

int main() {
    print(8); 
    print(4, 6); 
    print(3, 'a'); 
}
```
<details>
    <summary>Обяснение</summary>
- параметрите са изредени валидно в дефиницията на функцията - първо този без default стойност, а след него двата с такава<br>
- print(8) == print(8, 5, 'z') -> нищо особено<br>
- print(4, 6) == print(4, 6, 'z') -> нищо особено<br>
- print(3, 'a') = print(3, 97, 'z') -> както казахме, char-овете реално са числени стойности, които ни се представят по специален начин, и тук, понеже print() очаква вторият ѝ аргумент да е число, символът 'а' се превръща в числената си стойност, която е 97
</details>
<br>

**Въпрос 4:** Какво ще се изведе след изпълнение на кода?

```c++
#include <iostream>

int main() {
    int arr[];
    int arr[2];
    int arr[2] = { 1 };
    int arr[2] = { 1, 2, 3 };
}
```
<details>
    <summary>Обяснение</summary>
- първият не е валиден - не е ясно колко място да се задели за масива<br>
- вторият е валиден - създава се масив с два int елемента, който:<br>
    - ако е глобален, се запълва с нули<br>
    - ако не е глобален, т.е. е създаден в някоя функция, вкл. main(), не се знае какви стойности има(поне по стандарт, компилаторите може и да правят някакви работи) и да го четем е UB<br>
- третият е валиден(частична инициализация) - първият елемент е 1, а останалите са 0<br>
- четвъртият е невалиден - опитваме да инициализираме с повече елементи от заделените
</details>
<br>

**Въпрос 5:** Правилно ли бива обходен следният масив?

```c++
#include <iostream>

int main() {
    int arr[5] = { 1, 2, 3, 4, 5 };

    for (int i = 0; i <= 5; i++) {
        std::cout << arr[i] << " ";
    }
}
```
<details>
    <summary>Обяснение</summary>
Масив с размер N съхранява елементи на индекси от 0 до N-1, опит за достъпване на елемент на индекс N е опит да достъпим чужда памет.
</details>
<br>

**Въпрос 6:** Има ли грешка в тази функция?

```c++
#include <iostream>

void printArray(int arr[], size_t size) {
    for (size_t i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
}

int main() {
    
}
```
<details>
    <summary>Обяснение</summary>
Не точно "грешка", но в C++ е важен контролът върху константността на параметрите, а тук функцията printArray(), която чисто смислово би трябвало само да принтира масив и да не го променя по никакъв начин, приема масив като неконстантен, което не е добре. Стараем се ВИНАГИ, когато функция приема масив, да го приема като константен, ако той не се изменя вътре във функцията.
</details>
<br>

**Въпрос 7:** Двете извиквания на printArray() едно и също ли ще принтират?

```c++
#include <iostream>

void printArray(const int arr[], size_t size) {
    for (size_t i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
}

void incrementArray(int arr[], size_t size) {
    for (size_t i = 0; i < size; i++) {
        arr[i]++;
    }
}

int main() {
    int arr[5] = { 1, 2, 3, 4, 5 };
    printArray(arr, 5);
    incrementArray(arr, 5);
    printArray(arr, 5);
}
```
<details>
    <summary>Обяснение</summary>
- int arr[5] -> в 'arr' се запазва само адресът, на който започва масивът в паметта, а не самият масив с всичките си елементи<br>
- когато подаваме масив като аргумент на функция, това, което реално се подава, е копие на адреса на началото на масива, т.е. вътре във функцията се работи с абсолютно същия масив, който е бил подаден, а не с негово копие(може да се направи аналогия с подаването по референция, напр. int& a)<br>
- от това следва, че incrementArray() реално променя елементите в arr, и програмата изписва "1 2 3 4 5(масивът преди промяната) 2 3 4 5 6(масивът след промяната)"
</details>
<br>

**Въпрос 8:** Следният код компилира ли се?

```c++
#include <iostream>

void incrementArray(int[], size_t);

void printArray(const int arr[], size_t size) {
    incrementArray(arr, size);

    for (size_t i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

void incrementArray(int arr[], size_t size) {
    for (size_t i = 0; i < size; i++) {
        arr[i]++;
    }
}

int main() {
    int arr[5] = { 1, 2, 3, 4, 5 };
    printArray(arr, 5);
    incrementArray(arr, 5);
    printArray(arr, 5);
}
```
<details>
    <summary>Обяснение</summary>
Не се компилира, понеже в printArray(приема масив като константен) викаме incrementArray(приема масив като неконстантен, т.е. ще го променя). Това е идеята на const параметрите - да се пазим от инцидентни промени, който реално не искаме да се случват.
</details>
<br>

**Въпрос 9:** Какво ще изведе следният код?

```c++
#include <iostream>

void printArray(const int arr[], size_t size);

void f(const int arr[], size_t size) {
    int arr2[] = { 0, 0, 0, 0, 0 };
    arr = arr2;
    printArray(arr, size);
}

void printArray(const int arr[], size_t size) {
    for (size_t i = 0; i < size; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}

int main() {
    int arr[5] = { 1, 2, 3, 4, 5 };
    printArray(arr, 5);
    f(arr, 5);
    printArray(arr, 5);
}
```
<details>
    <summary>Обяснение</summary>
- както казахме горе, когато подаваме масив във функция, тя работи с КОПИЕ на адреса на началото на масива, т.е. това arr вътре в f() сочи към същия масив, към който сочи и arr в main(), но са РАЗЛИЧНИ променливи, които съдържат в себе си еднакъв адрес<br>
- вътре в f() създаваме някакъв друг масив arr2, който ще съществува само до края на изпълнението на функцията, а аrr2 ще сочи към неговия адрес<br>
- arr = arr2 -> тук казваме на arr в f(), КОЕТО Е РАЗЛИЧНО ОТ arr В main(), вече да сочи към началото на масива arr2<br>
- в момента arr в main() сочи към {1,2,3,4,5}, a arr в f() и arr2 сочат към {0,0,0,0,0}<br>
- принтовете са:<br>
    - "1 2 3 4 5" - ясно<br>
    - "0 0 0 0 0" - както казахме, arr в f() в този момент вече сочи към новия масив arr2<br>
    - "1 2 3 4 5" - arr в main() никога не се променя и се принтира, както и първия път
</details>
<br>

```cpp
    void cout(char a) { std::cout << a; } //1

    void cout(int a) { std::cout << a; } //2

    void cout(char a, int b) { std::cout << a << '-' << b; } //3

    void cout(double a, char b) { std::cout << b << '-' << a; } //4

    void cout(bool a) { std::cout << a; } //5

    void cout(char a, bool b, int c) { std::cout << a <<b << c; } //6

    void cout(const int a) { std::cout << a; } //7

    void cout(char a, unsigned b) { std::cout << a << '-' <<b; } //8

    void cout(char a, int b) { std::cout << a << '-' << b; } // 8.1

    char cout(char a) { return a; } //9

```
<details>
    <summary>Обяснение</summary>
- от 1 до 6 няма проблеми - параметрите или са от различен вид, или са с различен брой<br>
- 7 clash-ва с 2 - const параметри участват в различаването на функции, само когато подаваме по адрес, а тук подаваме по копие(func(int&) и func(const int&) биха се различавали без проблем)<br>
- 8 и 8.1 - различават се по втория си параметър
- 9 clash-ва с 1, понеже return type-ът на функцията не се използва са различаване между функции, а останалото(името и парамтерите) е еднакво при двете
</details>
<br>