# Подготовка за контролно 1

**1.** Кой от следните оператори не работи само с булева стойност?

- if
- switch
- &&
- ||

---
**2.** Напишете фунцкия `bool equals(double a, double b)`, която сравнява подадените им числа дали са равни. Ако са равни връща `true` иначе `false`

<details>
    <summary>Обяснение</summary>
Числа с плаваща запетая(double и float) НЕ се сравняват с ==, както целочислените типове.
<br><br>

```c++
constexpr double EPSILON = 0.0001;

double myabs(double a) {
    return a < 0 ? -a : a;
}

bool equals(double a, double b) {
    return myabs(a - b) < EPSILON;
}
```
<br><br>
EPSILON показва с каква точност ще сравняваме числата(ако не е указано в условието, можем да приемем, че 4-5 знака след запетаята са достатъчни). Сравняваме разликата на двете числа по АБСОЛЮТНА СТОЙНОСТ с EPSILON.
</details>

---
**3.** Дали ще се компилира следния код? Ако да какво ще изведе, Ако не Защо?
```cpp
#include <iostream>
int value = 42;
void f(int value) {
    value = 9;
    ::value = value;
}

int main() {
    int value = 3;
    std::cout << value << "\n";
    std::cout << ::value << "\n";

    f(value);
    std::cout << ::value << "\n";
    std::cout << value << "\n";
    return 0;
}
```
**4.** Какво ще изведе дадената операция Опишете в едно изречение?

```cpp
for (int i = 0; i < 100; i++) {
    for(int i = 0; i < 100; i++) {
        cout << i << " ";
    }
    cout << endl;
}
```
<details>
    <summary>Обяснение</summary>
Всеки for създава вътрешен scope, като променливите, инициализирани в самия for, са видими само в този вътрешен scope. Тъй като говорим за scope-ове, това означава, че променливи в по-вътрешен scope могат да shadow-ват(засенчват) тези в по-външен. Тук int i = 0 от вътрешния for няма да създаде проблем, именно защото се създава в по-вътрешен scope. 
<br><br>
Ако вътрешния for го нямаше и просто бяхме написали int i = 0 в тялото на външния, то това нямаше да се компилира, защото в scope, в който вече съществува променливата i, щяхме да опитаме да я създадем отново.<br>
<br><br>
Този пример обаче също е валиден. Тук вътрешният цикъл работи с променливата j, напълно различна от i-то на външния for, а вътре в самото тяло на вътрешния for си създаваме някакво друго i, което отново е в по-вътрешен scope, спрямо другото(оригиналното) i.

```c++
for (int i = 0; i < 100; i++) {
    for(int j = 0; j < 100; j++) {
        int i = 1;
        cout << i << " ";
    }
    cout << endl;
}
```
</details>

---

**5.** Какво ще се случи при този код?

```cpp
int main() {
    f();
    return 0;
}
void f() {
    cout << "f()" << endl;
}
```

---

**6.**
Какво прави следната функция?

```cpp
void swap(double a, double b) {
    double c = a;
    a = b;
    b = c;
}
```
<details>
    <summary>Обяснение</summary>
Най-добре е да се даде максимално изчерпателен отговор:<br><br>

Функцията разменя стойностите на параметрите 'a' и 'b', но това се отразява само вътре във функцията, понеже са подадени по стойност и работим с копия на променливите, които са били подадени при извикването на функцията. Работеща swap функция трябва да приема параметрите си по референция, за да се отразява размяната на самите променливи, които са подадени при извикването ѝ.
</details>


---

**7.** Какво ще отпечата следния код?

```cpp
#include <iostream>
bool f() {
    std::cout << 5;
    return false;
}
bool g() {
    std::cout << 123;
    return true;
}
bool h() {
    std::cout << 0;
    return true;
}
void k()
{
    std::cout << (h() || g() || f()) << std::endl;
    std::cout << (g() && f() && h()) << std::endl;
}
int main()
{
    k();
}
```
<details>
    <summary>Обяснение</summary>
!!!!! || и && оценяват аргументите си отляво надясно !!!!!<br><br>

Всяко извикване на функция се заменя със стойността, която тя връща.<br>
Тогава кодът в k() може да се презапише така:<br>

```cpp
void k()
{
    std::cout << (true || g() || f()) << std::endl;
    std::cout << (true && false && h()) << std::endl;
}
```

Гледаме първия cout -> (true || g() || f()) спира да оценява аргументите си след първия, понеже той е true и има short-circuit. Това обаче означава, че сме влезли в тялото на първата функция, изпълнили сме го и сме върнали това true. В тялото на h() има 'cout << 0', което се изпълнява и изписва '0' на конзолата, без да влияе нито на оценяването на f(), нито на оценяването на целия израз (h() || g() || f()). h() е върнала true -> целият израз е true -> изписват се 1 и нов ред.<br><br>

Дотук имаме "01\n".<br><br>

Гледаме втория cout, който спира да оценява аргументи след втория, отново заради short-circuit, понеже && е намерило false аргумент -> изпълнили сме телата на първите две функции, които са g()(изписва 123) и f()(изписва 5). Целият израз се оценява на false -> изписват се 0 и нов ред.<br><br>

От този ред имаме и "12350\n".<br><br>

-> програмата изписва "01\n12350\n".

</details>

---
**8.** Какво ще върне следната функция?
```cpp
double f()
{
     double num1 = 4;
     double num2 = 4 / 7;
     return (num2-- = ++++num1 + 2);
}
```
---

**9.** Какво ще изведе този код на конзолата?

```cpp
#include <iostream>

int main() {
    int x = 2;
    switch (x) {
        case 1:
            std::cout << "One" << std::endl;
        case 2:
            std::cout << "Two" << std::endl;
        case 3:
            std::cout << "Three" << std::endl;
        default:
            std::cout << "Default" << std::endl;
    }
    return 0;
}
```

---

**10.** Какво ще изведе този код на конзолата?

```cpp
#include <iostream>

int main() {
    for (int i = 0; i < 5; i++); {
        std::cout << "i = " << i << std::endl;
    }
    return 0;
}
```
<details>
    <summary>Обяснение</summary>
МНОГО внимавайте за ';', '=' и '==' на контролното. Тук ';' слага край на for-а и в последвалия scope-а се прави опит да се принтира i, което реално не е създадено никъде.
</details>
---

**11.** Какво ще изведе този код на конзолата?

```cpp
#include <iostream>

int main() {
    int i = 10;
    while (i = 5) {
        std::cout << i << " ";
        i--;
    }
    return 0;
}
```
**12** Какво ще изведе този код на конзолата?
```cpp
int i = 0;
while (++i, ++i < 14) {
    do
    {
        cout << i * 2 << endl;
    } while (i++ < 5);
}
```
<details>
    <summary>Обяснение</summary>

Всяка проверка на while цикъла:
- увеличава i с 2 и след това го сравнява с 14
<br>
Вътре в тялото на цикъла изпълняваме do-while, който принтира 'i*2', и след това прави проверката 'i++ < 5'.<br><br>

В първата итерация на while, i ще има стойност 2 -> в тялото на do-while ще влезем с i, равно на 2,3,4 и 5 -> ще се изпишат 4, 6, 8 и 10, всяко само на ред. Тук можем да забележим, че това е първата и последната итерация на while, в която ще изпълним do-while повече от веднъж, понеже ние само увеличаваме i и то никога повече няма да мине проверката 'i++ < 5'.<br><br>

От първата итерация на do-while сме излезли с i=6 -> в следващата итерация на while, i ще има стойност 8, ще се принтира 16 и i ще се увеличи с 1 от проверката в do-while.<br><br>

В следващата итерация на while влизаме с i=11, изписва се 22 и i се увеличава с 1 от проверката в do-while.<br><br>

Тук вече не миванаме проверката в while, понеже преди нея i=12, i се увеличава два пъти, i=14 и 'i < 14' връща false.<br><br>

Програмата изписвa:<br>
4<br>
6<br>
8<br>
10<br>
16<br>
22

</details>

---

**13.** Напишете еквивалентен код на следния програмен фрагмент, като използвате оператор switch веднъж (и не използвате if):

```cpp
int a;
if (a == 1)
    cout << “one”;
if (a != 3)
    cout << “13”;
else if (a > 3)
    cout << “big”;
else
    cout << “error”;
```

**14** Напишете еквивалентен код на следния програмен фрагмент, като използвате оператор switch веднъж (и не използвате if):

```cpp
(x == 10) && cout << "xyz";
((x == 4) || (x == 6)) ? cout << "this" :
	((x >= 6) && (x <= 8)) ? cout << "correct" : cout << "undef";
```
<details>
    <summary>Обяснение</summary>
Имаме 5 ключови стойности - 10, 4, 6, 7 и 8. Разглеждаме всяка от тях.<br><br>
При 10 -> принтира се "xyz" от първия израз и "undef" от втория, понеже не изпълнява нито едно от условията ((x==4) || (x==6)) и ((x >= 6) && (x <= 8)).<br>
При 4 и 6 -> принтира се само "this", защото удовлетворяват първото условие във втория израз.<br>
При 7 и 8 -> принтира се само "correct", защото удовлетворяват само второто условие на втория израз.<br>
При числа, различни от тези 5 -> принтира се само "undef", понеже не изпълняват нито едно условие(default случаят ни понеже покрива безкраен брой стойности).<br>

```c++
switch(x) {
    case 4:
    case 6: cout << "this"; break;
    case 7:
    case 8: cout << "correct"; break;
    case 10: cout << "xyz";
    default: cout << "undef"; break; // може и без последния break, няма значение
}
```
<br>
Както казахме, числата 4,6,7 и 8 попадат само в един случай, в който нито едно друго число не попада -> за тях правим case-ове, които изписват съответния текст и break-ват, но внимаваме да ги направим по начин, по който няма да е възможно пропадането вътре в тях.<br>

След това имаме случаите с 10 и всички числа извън множеството {4,6,7,8,10}. За 'case 10:' имаме две възможности:<br>
- да изписваме "xyz" и да пропадаме в default, където да се изписва "undef".
- да изписваме "xyzundef" и да не ни се налага да пропадаме в default, като това ни позволява да си разположим default случая където поискаме, стига да има break, ако не е последен.<br>

```c++
switch(x) {
    case 10: cout << "xyzundef"; break;
    case 4: cout << "this"; break;
    case 7: cout << "correct"; break;
    case 6: cout << "this"; break;
    default: cout << "undef"; break;
    case 8: cout << "correct"; break;
}
```

Това също е вярно, макар и доста по-грозно, но пък ни позволява да не се притесняваме за подредбата на случаите, понеже всеки има break в себе си.

</details>

---

**15.** Опишете последователно точно какво ще изведе на екрана следният програмен фрагмент. Обосновете писмено подробно отговора си.

```cpp
for (int i = 9; i <= 16; cout << i << endl) i++;
```

---

**16.** Ще се компилира ли следният програмен фрагмент:

```cpp
int num1 = 5;
int num2 = 13;
num2++ = ++num1 + 12;
```

В случай че компилацията е възможна, каква стойност ще има
променливата num2 след изпълнението му?

**17.** Опишете последователно точно какво ще изведе на екрана следният програмен фрагмент. Обосновете писмено подробно отговора си.
```cpp
for (int i = -10; i++; i++) cout << i << ' ' << endl;
```
